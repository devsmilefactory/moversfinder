/**
 * PWA Update Notification Component
 * 
 * Displays a PRIORITY notification when a new version of the app is available.
 * High-visibility, persistent notification that cannot be easily dismissed.
 * 
 * Works with Workbox (via vite-plugin-pwa) for robust PWA functionality.
 */

import React, { useEffect, useState, useRef } from 'react';
import { RefreshCw, X, AlertCircle, Download, Sparkles } from 'lucide-react';
import Button from '../ui/Button';
import { handleAppUpdate, getCurrentVersion } from '../../utils/versionManager';

const PWAUpdateNotification = () => {
  const [showReloadPrompt, setShowReloadPrompt] = useState(false);
  const [isUpdating, setIsUpdating] = useState(false);
  const [offlineReady, setOfflineReady] = useState(false);
  const [needRefresh, setNeedRefresh] = useState(false);
  const [newVersion, setNewVersion] = useState(null);
  const [hasPlayedSound, setHasPlayedSound] = useState(false);
  const registrationRef = useRef(null);
  const updateCheckIntervalRef = useRef(null);
  const soundRef = useRef(null);

  useEffect(() => {
    if (!('serviceWorker' in navigator)) {
      return;
    }

    // Register service worker and handle updates
    // Workbox generates sw.js at build time
    const registerSW = async () => {
      try {
        // Try to register Workbox service worker (generated by vite-plugin-pwa)
        // Fallback to custom sw.js if Workbox isn't available
        const swPath = '/sw.js';
        
        const registration = await navigator.serviceWorker.register(swPath, {
          scope: '/',
          updateViaCache: 'none' // Always check for updates
        });

        registrationRef.current = registration;
        console.log('âœ… Service Worker registered (Workbox):', registration.scope);

        // Track offline ready event
        if (window.gtag) {
          window.gtag('event', 'pwa_offline_ready', {
            event_category: 'engagement'
          });
        }

        // Wait for service worker to be ready
        await navigator.serviceWorker.ready;
        setOfflineReady(true);
        // Hide offline ready notification after 5 seconds
        setTimeout(() => setOfflineReady(false), 5000);

        // Check for updates more frequently (every 5 minutes)
        updateCheckIntervalRef.current = setInterval(() => {
          console.log('ðŸ”„ Checking for service worker updates...');
          registration.update();
        }, 5 * 60 * 1000); // 5 minutes for faster detection

        // Listen for service worker updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed') {
                // Check if there's a controller (existing service worker)
                if (navigator.serviceWorker.controller) {
                  // New service worker available, but old one is still active
                  console.log('ðŸ”„ NEW VERSION AVAILABLE - Priority notification');
                  const currentVersion = getCurrentVersion();
                  setNewVersion(currentVersion);
                  setShowReloadPrompt(true);
                  setNeedRefresh(true);

                  // Play notification sound (if permission granted)
                  if (!hasPlayedSound && 'Notification' in window && Notification.permission === 'granted') {
                    try {
                      // Create a simple beep sound using Web Audio API
                      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                      const oscillator = audioContext.createOscillator();
                      const gainNode = audioContext.createGain();
                      
                      oscillator.connect(gainNode);
                      gainNode.connect(audioContext.destination);
                      
                      oscillator.frequency.value = 800;
                      oscillator.type = 'sine';
                      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                      
                      oscillator.start(audioContext.currentTime);
                      oscillator.stop(audioContext.currentTime + 0.5);
                      setHasPlayedSound(true);
                    } catch (e) {
                      console.warn('Could not play notification sound:', e);
                    }
                  }

                  // Vibrate if supported
                  if ('vibrate' in navigator) {
                    try {
                      navigator.vibrate([200, 100, 200]);
                    } catch (e) {
                      console.warn('Vibration not supported:', e);
                    }
                  }

                  // Show browser notification if permission granted
                  if ('Notification' in window && Notification.permission === 'granted') {
                    try {
                      const notification = new Notification('New Version Available', {
                        body: 'A new version of TaxiCab is ready. Click to update.',
                        icon: '/icons/icon-192x192.png',
                        badge: '/icons/icon-192x192.png',
                        tag: 'app-update',
                        requireInteraction: true,
                        silent: false
                      });

                      notification.onclick = () => {
                        window.focus();
                        notification.close();
                      };
                    } catch (e) {
                      console.warn('Could not show browser notification:', e);
                    }
                  }

                  // Track update available event
                  if (window.gtag) {
                    window.gtag('event', 'pwa_update_available', {
                      event_category: 'engagement',
                      event_label: currentVersion
                    });
                  }
                } else {
                  // First time installation
                  console.log('âœ… Service Worker installed for the first time');
                }
              }
            });
          }
        });

        // Listen for controller change (service worker activated)
        // Workbox uses skipWaiting, so this will fire when new SW takes control
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('ðŸ”„ Service Worker controller changed (Workbox activated)');
          // Reload to get the new version
          window.location.reload();
        });

      } catch (error) {
        console.error('âŒ Service Worker registration error:', error);
      }
    };

    // Only register in production
    if (import.meta.env.PROD) {
      registerSW();
    }

    // Cleanup
    return () => {
      if (updateCheckIntervalRef.current) {
        clearInterval(updateCheckIntervalRef.current);
      }
    };
  }, []);

  const handleUpdate = async () => {
    setIsUpdating(true);

    try {
      console.log('ðŸ”„ PWA Update: Starting update process...');

      // Track update acceptance
      if (window.gtag) {
        window.gtag('event', 'pwa_update_accepted', {
          event_category: 'engagement'
        });
      }

      // Clear all caches and auth state before updating
      console.log('ðŸ§¹ Clearing caches before update...');
      await handleAppUpdate();

      // Get the service worker registration
      const registration = registrationRef.current || await navigator.serviceWorker.ready;

      if (registration && registration.waiting) {
        // Workbox uses skipWaiting: true, so we just need to send SKIP_WAITING message
        // This will activate the waiting service worker immediately
        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
        
        // Workbox will handle the activation, controllerchange event will fire
        // and trigger the reload via the event listener
      } else if (registration) {
        // Force update check if no waiting worker
        await registration.update();
        
        // If update found, wait a bit for it to install
        setTimeout(() => {
          if (registration.waiting) {
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
          } else {
            // Reload to get any updates
            window.location.reload();
          }
        }, 500);
      } else {
        // Fallback: just reload
        window.location.reload();
      }

      // Reload the page after a short delay (controllerchange should handle this, but backup)
      setTimeout(() => {
        console.log('ðŸ”„ Force reloading page...');
        window.location.reload();
      }, 1500);
    } catch (error) {
      console.error('âŒ Error updating service worker:', error);
      setIsUpdating(false);

      // Even if there's an error, try to reload to get the new version
      setTimeout(() => {
        console.log('ðŸ”„ Reloading despite error...');
        window.location.reload();
      }, 2000);
    }
  };

  const handleDismiss = () => {
    // Don't allow easy dismissal - show warning
    if (window.confirm('A new version is available. Are you sure you want to continue using the old version? Some features may not work correctly.')) {
      setShowReloadPrompt(false);
      setNeedRefresh(false);
      
      // Track dismissal
      if (window.gtag) {
        window.gtag('event', 'pwa_update_dismissed', {
          event_category: 'engagement'
        });
      }
      
      // Re-show after 30 seconds to remind user
      setTimeout(() => {
        if (registrationRef.current?.waiting) {
          setShowReloadPrompt(true);
          setNeedRefresh(true);
        }
      }, 30000);
    }
  };

  // Offline Ready Toast
  if (offlineReady && !needRefresh) {
    return (
      <div className="fixed top-4 right-4 z-[9999] max-w-sm animate-slide-in-right">
        <div className="bg-green-600 text-white rounded-lg shadow-2xl p-4">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0">
              <div className="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center">
                <AlertCircle className="w-6 h-6" />
              </div>
            </div>
            <div className="flex-1">
              <h4 className="font-semibold mb-1">App Ready for Offline Use</h4>
              <p className="text-sm text-white/90">
                TaxiCab is now available offline!
              </p>
            </div>
            <button
              onClick={() => setOfflineReady(false)}
              className="flex-shrink-0 text-white/80 hover:text-white"
              aria-label="Close"
            >
              <X className="w-5 h-5" />
            </button>
          </div>
        </div>
      </div>
    );
  }

  // PRIORITY Update Notification - Full-width banner, high visibility
  if (showReloadPrompt && needRefresh) {
    return (
      <>
        {/* Backdrop overlay */}
        <div 
          className="fixed inset-0 bg-black/50 z-[9998] animate-fade-in"
          onClick={(e) => {
            // Don't close on backdrop click - require explicit action
            e.stopPropagation();
          }}
        />
        
        {/* Priority Update Banner */}
        <div className="fixed top-0 left-0 right-0 z-[9999] animate-slide-down">
          <div className="bg-gradient-to-r from-blue-600 via-blue-700 to-indigo-700 text-white shadow-2xl border-b-4 border-yellow-400">
            <div className="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8">
              <div className="flex items-center gap-4">
                {/* Animated Icon */}
                <div className="flex-shrink-0">
                  <div className="w-14 h-14 bg-white/20 rounded-full flex items-center justify-center animate-pulse">
                    <Sparkles className="w-8 h-8 text-yellow-300" />
                  </div>
                </div>

                {/* Content */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="text-lg font-bold flex items-center gap-2">
                      <Download className="w-5 h-5" />
                      New Version Available!
                    </h3>
                    {newVersion && (
                      <span className="text-xs bg-white/20 px-2 py-1 rounded-full">
                        v{newVersion}
                      </span>
                    )}
                  </div>
                  <p className="text-sm text-white/90 mb-3">
                    A new version of TaxiCab is ready with improvements and bug fixes. 
                    <strong className="ml-1">Please update now to ensure the best experience.</strong>
                  </p>

                  {/* Action Buttons */}
                  <div className="flex flex-wrap gap-2">
                    <Button
                      onClick={handleUpdate}
                      disabled={isUpdating}
                      className="bg-white text-blue-700 hover:bg-gray-100 font-bold px-6 py-3 rounded-lg text-base flex items-center gap-2 disabled:opacity-50 shadow-lg hover:shadow-xl transition-all"
                      size="lg"
                    >
                      {isUpdating ? (
                        <>
                          <RefreshCw className="w-5 h-5 animate-spin" />
                          Updating...
                        </>
                      ) : (
                        <>
                          <RefreshCw className="w-5 h-5" />
                          Update Now
                        </>
                      )}
                    </Button>
                    <button
                      onClick={handleDismiss}
                      disabled={isUpdating}
                      className="text-white/90 hover:text-white text-sm font-medium px-4 py-3 border border-white/30 rounded-lg hover:bg-white/10 transition-colors disabled:opacity-50"
                    >
                      Remind Me Later
                    </button>
                  </div>
                </div>

                {/* Close button (with warning) */}
                <button
                  onClick={handleDismiss}
                  disabled={isUpdating}
                  className="flex-shrink-0 text-white/80 hover:text-white p-2 rounded-lg hover:bg-white/10 transition-colors disabled:opacity-50"
                  aria-label="Dismiss"
                  title="Dismiss (not recommended)"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>
          </div>
        </div>
      </>
    );
  }

  return null;
};

export default PWAUpdateNotification;
