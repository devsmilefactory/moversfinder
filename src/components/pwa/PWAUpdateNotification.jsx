/**
 * PWA Update Notification Component
 * 
 * Displays a PRIORITY notification when a new version of the app is available.
 * High-visibility, persistent notification that cannot be easily dismissed.
 * 
 * Works with Workbox (via vite-plugin-pwa) for robust PWA functionality.
 */

import React, { useEffect, useState, useRef } from 'react';
import { RefreshCw, X, Download, Sparkles } from 'lucide-react';
import Button from '../ui/Button';
import { handleAppUpdate, getCurrentVersion, getStoredVersion, isAppUpdated } from '../../utils/versionManager';
import { sendAppUpdateNotification, checkAndNotifyAppUpdate } from '../../services/appUpdateNotificationService';
import { useAuthStore } from '../../stores';

const PWAUpdateNotification = () => {
  const { user } = useAuthStore();
  const [showReloadPrompt, setShowReloadPrompt] = useState(false);
  const [isUpdating, setIsUpdating] = useState(false);
  const [needRefresh, setNeedRefresh] = useState(false);
  const [newVersion, setNewVersion] = useState(null);
  const [hasPlayedSound, setHasPlayedSound] = useState(false);
  const [pushNotificationSent, setPushNotificationSent] = useState(false);
  const registrationRef = useRef(null);
  const updateCheckIntervalRef = useRef(null);
  const soundRef = useRef(null);

  // Check for version changes on page load (automatic update detection on refresh)
  useEffect(() => {
    // Check if app version changed on page load/refresh
    const storedVersion = getStoredVersion();
    const currentVersion = getCurrentVersion();
    
    // Only check if we have a stored version (not first run) and versions differ
    if (storedVersion && storedVersion !== currentVersion && !showReloadPrompt) {
      console.log('ðŸ”„ Version change detected on page load - showing update prompt');
      console.log(`   Previous: ${storedVersion} â†’ Current: ${currentVersion}`);
      setNewVersion(currentVersion);
      setShowReloadPrompt(true);
      setNeedRefresh(true);
      
      // Send push notification if user is authenticated
      if (user?.id && !pushNotificationSent) {
        sendAppUpdateNotification(user.id, currentVersion, storedVersion)
          .then((result) => {
            if (result.success) {
              console.log('âœ… App update push notification sent');
              setPushNotificationSent(true);
            }
          })
          .catch((error) => {
            console.error('Error sending app update push notification:', error);
          });
      }
    }
  }, []); // Only run once on mount

  // Check for update query parameter and show update prompt
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('update') === 'true' && !showReloadPrompt) {
      // User clicked on update notification - show update prompt
      const checkForUpdate = async () => {
        try {
          const registration = registrationRef.current || await navigator.serviceWorker.ready;
          if (registration) {
            if (registration.waiting) {
              setShowReloadPrompt(true);
              setNeedRefresh(true);
              setNewVersion(getCurrentVersion());
            } else {
              // Check for updates
              await registration.update();
              // After update check, see if there's a waiting worker
              setTimeout(() => {
                if (registration.waiting) {
                  setShowReloadPrompt(true);
                  setNeedRefresh(true);
                  setNewVersion(getCurrentVersion());
                }
              }, 1000);
            }
          }
        } catch (error) {
          console.error('Error checking for updates:', error);
        }
      };
      
      checkForUpdate();
      
      // Clean up URL
      window.history.replaceState({}, '', window.location.pathname);
    }
  }, [showReloadPrompt]);

  useEffect(() => {
    if (!('serviceWorker' in navigator)) {
      return;
    }

    // Register service worker and handle updates
    // Workbox generates sw.js at build time
    const registerSW = async () => {
      try {
        // Try to register Workbox service worker (generated by vite-plugin-pwa)
        // Fallback to custom sw.js if Workbox isn't available
        const swPath = '/sw.js';
        
        const registration = await navigator.serviceWorker.register(swPath, {
          scope: '/',
          updateViaCache: 'none' // Always check for updates
        });

        registrationRef.current = registration;
        console.log('âœ… Service Worker registered (Workbox):', registration.scope);

        // Wait for service worker to be ready
        await navigator.serviceWorker.ready;

        // IMMEDIATELY check for updates on page load/refresh
        // This is critical for detecting updates when user refreshes the page
        console.log('ðŸ”„ Checking for updates on page load...');
        await registration.update();
        
        // Check if there's already a waiting service worker (update available)
        if (registration.waiting) {
          console.log('ðŸ”„ Update available (waiting service worker found on page load)');
          const currentVersion = getCurrentVersion();
          const storedVersion = getStoredVersion();
          setNewVersion(currentVersion);
          setShowReloadPrompt(true);
          setNeedRefresh(true);
          
          // Send push notification if user is authenticated
          if (user?.id && !pushNotificationSent) {
            sendAppUpdateNotification(user.id, currentVersion, storedVersion || currentVersion)
              .then((result) => {
                if (result.success) {
                  console.log('âœ… App update push notification sent');
                  setPushNotificationSent(true);
                }
              })
              .catch((error) => {
                console.error('Error sending app update push notification:', error);
              });
          }
        }

        // Check for updates periodically (every 2 minutes for robust detection)
        updateCheckIntervalRef.current = setInterval(() => {
          console.log('ðŸ”„ Checking for service worker updates...');
          registration.update().catch((error) => {
            console.warn('Error checking for service worker updates:', error);
          });
          
          // Also check version and send push notification if needed
          if (user?.id) {
            checkAndNotifyAppUpdate(user.id).catch((error) => {
              console.error('Error checking app update:', error);
            });
          }
        }, 2 * 60 * 1000); // 2 minutes for faster, more robust detection

        // Listen for service worker updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed') {
                // Check if there's a controller (existing service worker)
                if (navigator.serviceWorker.controller) {
                  // New service worker available, but old one is still active
                  console.log('ðŸ”„ NEW VERSION AVAILABLE - Priority notification');
                  const currentVersion = getCurrentVersion();
                  const storedVersion = getStoredVersion();
                  setNewVersion(currentVersion);
                  setShowReloadPrompt(true);
                  setNeedRefresh(true);

                  // Send push notification via FCM (if user is authenticated)
                  if (user?.id && !pushNotificationSent) {
                    sendAppUpdateNotification(user.id, currentVersion, storedVersion || currentVersion)
                      .then((result) => {
                        if (result.success) {
                          console.log('âœ… App update push notification sent');
                          setPushNotificationSent(true);
                        } else {
                          console.warn('Could not send app update push notification:', result.error);
                        }
                      })
                      .catch((error) => {
                        console.error('Error sending app update push notification:', error);
                      });
                  }

                  // Play notification sound (if permission granted)
                  if (!hasPlayedSound && 'Notification' in window && Notification.permission === 'granted') {
                    try {
                      // Create a simple beep sound using Web Audio API
                      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                      const oscillator = audioContext.createOscillator();
                      const gainNode = audioContext.createGain();
                      
                      oscillator.connect(gainNode);
                      gainNode.connect(audioContext.destination);
                      
                      oscillator.frequency.value = 800;
                      oscillator.type = 'sine';
                      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                      
                      oscillator.start(audioContext.currentTime);
                      oscillator.stop(audioContext.currentTime + 0.5);
                      setHasPlayedSound(true);
                    } catch (e) {
                      console.warn('Could not play notification sound:', e);
                    }
                  }

                  // Vibrate if supported
                  if ('vibrate' in navigator) {
                    try {
                      navigator.vibrate([200, 100, 200]);
                    } catch (e) {
                      console.warn('Vibration not supported:', e);
                    }
                  }

                  // Show browser notification if permission granted (fallback if push fails)
                  if ('Notification' in window && Notification.permission === 'granted') {
                    try {
                      const notification = new Notification('New Version Available', {
                        body: 'A new version of TaxiCab is ready. Click to update.',
                        icon: '/icons/icon-192x192.png',
                        badge: '/icons/icon-192x192.png',
                        tag: 'app-update',
                        requireInteraction: true,
                        silent: false,
                        data: {
                          url: '/?update=true',
                          type: 'app_update',
                        },
                      });

                      notification.onclick = () => {
                        window.focus();
                        window.location.href = '/?update=true';
                        notification.close();
                      };
                    } catch (e) {
                      console.warn('Could not show browser notification:', e);
                    }
                  }

                  // Track update available event
                  if (window.gtag) {
                    window.gtag('event', 'pwa_update_available', {
                      event_category: 'engagement',
                      event_label: currentVersion
                    });
                  }
                } else {
                  // First time installation
                  console.log('âœ… Service Worker installed for the first time');
                }
              }
            });
          }
        });

        // Listen for controller change (service worker activated)
        // Workbox uses skipWaiting, so this will fire when new SW takes control
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('ðŸ”„ Service Worker controller changed (Workbox activated)');
          // Reload to get the new version
          window.location.reload();
        });

      } catch (error) {
        console.error('âŒ Service Worker registration error:', error);
      }
    };

    // Only register in production (service worker is disabled in dev mode by vite-plugin-pwa)
    // In dev mode, Firebase will handle missing service worker gracefully
    if (import.meta.env.PROD) {
      registerSW();
    }

    // Cleanup
    return () => {
      if (updateCheckIntervalRef.current) {
        clearInterval(updateCheckIntervalRef.current);
      }
    };
  }, []);

  const handleUpdate = async () => {
    setIsUpdating(true);

    try {
      console.log('ðŸ”„ PWA Update: Starting update process...');

      // Track update acceptance
      if (window.gtag) {
        window.gtag('event', 'pwa_update_accepted', {
          event_category: 'engagement'
        });
      }

      // Clear all caches and auth state before updating
      console.log('ðŸ§¹ Clearing caches before update...');
      await handleAppUpdate();

      // Get the service worker registration
      const registration = registrationRef.current || await navigator.serviceWorker.ready;

      if (registration && registration.waiting) {
        // Workbox uses skipWaiting: true, so we just need to send SKIP_WAITING message
        // This will activate the waiting service worker immediately
        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
        
        // Workbox will handle the activation, controllerchange event will fire
        // and trigger the reload via the event listener
      } else if (registration) {
        // Force update check if no waiting worker
        await registration.update();
        
        // If update found, wait a bit for it to install
        setTimeout(() => {
          if (registration.waiting) {
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
          } else {
            // Reload to get any updates
            window.location.reload();
          }
        }, 500);
      } else {
        // Fallback: just reload
        window.location.reload();
      }

      // Reload the page after a short delay (controllerchange should handle this, but backup)
      setTimeout(() => {
        console.log('ðŸ”„ Force reloading page...');
        window.location.reload();
      }, 1500);
    } catch (error) {
      console.error('âŒ Error updating service worker:', error);
      setIsUpdating(false);

      // Even if there's an error, try to reload to get the new version
      setTimeout(() => {
        console.log('ðŸ”„ Reloading despite error...');
        window.location.reload();
      }, 2000);
    }
  };

  const handleDismiss = () => {
    // Don't allow easy dismissal - show warning
    if (window.confirm('A new version is available. Are you sure you want to continue using the old version? Some features may not work correctly.')) {
      setShowReloadPrompt(false);
      setNeedRefresh(false);
      
      // Track dismissal
      if (window.gtag) {
        window.gtag('event', 'pwa_update_dismissed', {
          event_category: 'engagement'
        });
      }
      
      // Re-show after 30 seconds to remind user
      setTimeout(() => {
        if (registrationRef.current?.waiting) {
          setShowReloadPrompt(true);
          setNeedRefresh(true);
        }
      }, 30000);
    }
  };

  // PRIORITY Update Notification - Full-width banner, high visibility
  if (showReloadPrompt && needRefresh) {
    return (
      <>
        {/* Backdrop overlay */}
        <div 
          className="fixed inset-0 bg-black/50 z-[9998] animate-fade-in"
          onClick={(e) => {
            // Don't close on backdrop click - require explicit action
            e.stopPropagation();
          }}
        />
        
        {/* Priority Update Banner */}
        <div className="fixed top-0 left-0 right-0 z-[9999] animate-slide-down">
          <div className="bg-gradient-to-r from-blue-600 via-blue-700 to-indigo-700 text-white shadow-2xl border-b-4 border-yellow-400">
            <div className="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8">
              <div className="flex items-center gap-4">
                {/* Animated Icon */}
                <div className="flex-shrink-0">
                  <div className="w-14 h-14 bg-white/20 rounded-full flex items-center justify-center animate-pulse">
                    <Sparkles className="w-8 h-8 text-yellow-300" />
                  </div>
                </div>

                {/* Content */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="text-lg font-bold flex items-center gap-2">
                      <Download className="w-5 h-5" />
                      New Version Available!
                    </h3>
                    {newVersion && (
                      <span className="text-xs bg-white/20 px-2 py-1 rounded-full">
                        v{newVersion}
                      </span>
                    )}
                  </div>
                  <p className="text-sm text-white/90 mb-3">
                    A new version of TaxiCab is ready with improvements and bug fixes. 
                    <strong className="ml-1">Please update now to ensure the best experience.</strong>
                  </p>

                  {/* Action Buttons */}
                  <div className="flex flex-wrap gap-2">
                    <Button
                      onClick={handleUpdate}
                      disabled={isUpdating}
                      className="bg-white text-blue-700 hover:bg-gray-100 font-bold px-6 py-3 rounded-lg text-base flex items-center gap-2 disabled:opacity-50 shadow-lg hover:shadow-xl transition-all"
                      size="lg"
                    >
                      {isUpdating ? (
                        <>
                          <RefreshCw className="w-5 h-5 animate-spin" />
                          Updating...
                        </>
                      ) : (
                        <>
                          <RefreshCw className="w-5 h-5" />
                          Update Now
                        </>
                      )}
                    </Button>
                    <button
                      onClick={handleDismiss}
                      disabled={isUpdating}
                      className="text-white/90 hover:text-white text-sm font-medium px-4 py-3 border border-white/30 rounded-lg hover:bg-white/10 transition-colors disabled:opacity-50"
                    >
                      Remind Me Later
                    </button>
                  </div>
                </div>

                {/* Close button (with warning) */}
                <button
                  onClick={handleDismiss}
                  disabled={isUpdating}
                  className="flex-shrink-0 text-white/80 hover:text-white p-2 rounded-lg hover:bg-white/10 transition-colors disabled:opacity-50"
                  aria-label="Dismiss"
                  title="Dismiss (not recommended)"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
            </div>
          </div>
        </div>
      </>
    );
  }

  return null;
};

export default PWAUpdateNotification;
