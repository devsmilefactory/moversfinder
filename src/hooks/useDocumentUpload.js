import { useState, useCallback, useMemo } from 'react';\nimport { supabase } from '../lib/supabase';\nimport useAuthStore from '../stores/authStore';\n\n/**\n * useDocumentUpload Hook\n * \n * Provides document upload functionality for profile forms including:\n * - File validation\n * - Upload progress tracking\n * - Error handling\n * - Multiple file support\n * - Preview generation\n */\nconst useDocumentUpload = ({\n  bucket = 'documents',\n  maxFileSize = 5 * 1024 * 1024, // 5MB\n  allowedTypes = ['image/jpeg', 'image/png', 'image/jpg', 'application/pdf'],\n  generateThumbnails = true\n}) => {\n  const user = useAuthStore((state) => state.user);\n  const [uploads, setUploads] = useState({});\n  const [uploadProgress, setUploadProgress] = useState({});\n  const [uploadErrors, setUploadErrors] = useState({});\n  const [previews, setPreviews] = useState({});\n\n  // Validate file\n  const validateFile = useCallback((file) => {\n    const errors = [];\n\n    if (!file) {\n      errors.push('No file selected');\n      return errors;\n    }\n\n    // Check file size\n    if (file.size > maxFileSize) {\n      errors.push(`File size must be less than ${Math.round(maxFileSize / 1024 / 1024)}MB`);\n    }\n\n    // Check file type\n    if (!allowedTypes.includes(file.type)) {\n      errors.push(`File type not supported. Allowed types: ${allowedTypes.join(', ')}`);\n    }\n\n    // Check file name\n    if (file.name.length > 100) {\n      errors.push('File name is too long');\n    }\n\n    return errors;\n  }, [maxFileSize, allowedTypes]);\n\n  // Generate file preview\n  const generatePreview = useCallback((file, fieldName) => {\n    if (!generateThumbnails || !file) return;\n\n    if (file.type.startsWith('image/')) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        setPreviews(prev => ({\n          ...prev,\n          [fieldName]: {\n            type: 'image',\n            url: e.target.result,\n            name: file.name,\n            size: file.size\n          }\n        }));\n      };\n      reader.readAsDataURL(file);\n    } else if (file.type === 'application/pdf') {\n      setPreviews(prev => ({\n        ...prev,\n        [fieldName]: {\n          type: 'pdf',\n          name: file.name,\n          size: file.size\n        }\n      }));\n    }\n  }, [generateThumbnails]);\n\n  // Set file for upload\n  const setFile = useCallback((fieldName, file) => {\n    // Clear previous errors\n    setUploadErrors(prev => {\n      const newErrors = { ...prev };\n      delete newErrors[fieldName];\n      return newErrors;\n    });\n\n    if (!file) {\n      // Remove file\n      setUploads(prev => {\n        const newUploads = { ...prev };\n        delete newUploads[fieldName];\n        return newUploads;\n      });\n      setPreviews(prev => {\n        const newPreviews = { ...prev };\n        delete newPreviews[fieldName];\n        return newPreviews;\n      });\n      return;\n    }\n\n    // Validate file\n    const validationErrors = validateFile(file);\n    if (validationErrors.length > 0) {\n      setUploadErrors(prev => ({\n        ...prev,\n        [fieldName]: validationErrors[0]\n      }));\n      return;\n    }\n\n    // Set file for upload\n    setUploads(prev => ({\n      ...prev,\n      [fieldName]: file\n    }));\n\n    // Generate preview\n    generatePreview(file, fieldName);\n  }, [validateFile, generatePreview]);\n\n  // Upload single file\n  const uploadFile = useCallback(async (fieldName, customPath = null) => {\n    const file = uploads[fieldName];\n    if (!file || !user?.id) {\n      throw new Error('No file to upload or user not authenticated');\n    }\n\n    // Clear previous errors\n    setUploadErrors(prev => {\n      const newErrors = { ...prev };\n      delete newErrors[fieldName];\n      return newErrors;\n    });\n\n    try {\n      // Generate file path\n      const fileExt = file.name.split('.').pop();\n      const fileName = customPath || `${user.id}/${fieldName}_${Date.now()}.${fileExt}`;\n\n      // Set initial progress\n      setUploadProgress(prev => ({ ...prev, [fieldName]: 0 }));\n\n      // Upload file\n      const { data, error } = await supabase.storage\n        .from(bucket)\n        .upload(fileName, file, {\n          onUploadProgress: (progress) => {\n            const percentage = Math.round((progress.loaded / progress.total) * 100);\n            setUploadProgress(prev => ({ ...prev, [fieldName]: percentage }));\n          }\n        });\n\n      if (error) throw error;\n\n      // Get public URL\n      const { data: { publicUrl } } = supabase.storage\n        .from(bucket)\n        .getPublicUrl(fileName);\n\n      // Complete upload\n      setUploadProgress(prev => ({ ...prev, [fieldName]: 100 }));\n\n      return {\n        path: data.path,\n        publicUrl,\n        fileName: file.name,\n        fileSize: file.size,\n        fileType: file.type\n      };\n    } catch (error) {\n      setUploadErrors(prev => ({\n        ...prev,\n        [fieldName]: error.message || 'Upload failed'\n      }));\n      setUploadProgress(prev => {\n        const newProgress = { ...prev };\n        delete newProgress[fieldName];\n        return newProgress;\n      });\n      throw error;\n    }\n  }, [uploads, user?.id, bucket]);\n\n  // Upload multiple files\n  const uploadFiles = useCallback(async (fieldNames = null) => {\n    const filesToUpload = fieldNames || Object.keys(uploads);\n    const results = {};\n    const errors = {};\n\n    for (const fieldName of filesToUpload) {\n      try {\n        const result = await uploadFile(fieldName);\n        results[fieldName] = result;\n      } catch (error) {\n        errors[fieldName] = error.message;\n      }\n    }\n\n    return { results, errors };\n  }, [uploads, uploadFile]);\n\n  // Remove file\n  const removeFile = useCallback((fieldName) => {\n    setUploads(prev => {\n      const newUploads = { ...prev };\n      delete newUploads[fieldName];\n      return newUploads;\n    });\n    \n    setPreviews(prev => {\n      const newPreviews = { ...prev };\n      delete newPreviews[fieldName];\n      return newPreviews;\n    });\n    \n    setUploadErrors(prev => {\n      const newErrors = { ...prev };\n      delete newErrors[fieldName];\n      return newErrors;\n    });\n    \n    setUploadProgress(prev => {\n      const newProgress = { ...prev };\n      delete newProgress[fieldName];\n      return newProgress;\n    });\n  }, []);\n\n  // Clear all files\n  const clearAll = useCallback(() => {\n    setUploads({});\n    setPreviews({});\n    setUploadErrors({});\n    setUploadProgress({});\n  }, []);\n\n  // Get file info\n  const getFileInfo = useCallback((fieldName) => {\n    const file = uploads[fieldName];\n    const preview = previews[fieldName];\n    const error = uploadErrors[fieldName];\n    const progress = uploadProgress[fieldName];\n\n    return {\n      file,\n      preview,\n      error,\n      progress,\n      isUploading: progress !== undefined && progress < 100,\n      isUploaded: progress === 100,\n      hasError: !!error,\n      hasFile: !!file\n    };\n  }, [uploads, previews, uploadErrors, uploadProgress]);\n\n  // Format file size\n  const formatFileSize = useCallback((bytes) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }, []);\n\n  // Get upload summary\n  const getUploadSummary = useMemo(() => {\n    const totalFiles = Object.keys(uploads).length;\n    const uploadingFiles = Object.values(uploadProgress).filter(p => p < 100).length;\n    const uploadedFiles = Object.values(uploadProgress).filter(p => p === 100).length;\n    const errorFiles = Object.keys(uploadErrors).length;\n\n    return {\n      totalFiles,\n      uploadingFiles,\n      uploadedFiles,\n      errorFiles,\n      isUploading: uploadingFiles > 0,\n      allUploaded: totalFiles > 0 && uploadedFiles === totalFiles,\n      hasErrors: errorFiles > 0\n    };\n  }, [uploads, uploadProgress, uploadErrors]);\n\n  return {\n    // State\n    uploads,\n    uploadProgress,\n    uploadErrors,\n    previews,\n    \n    // Actions\n    setFile,\n    uploadFile,\n    uploadFiles,\n    removeFile,\n    clearAll,\n    \n    // Utilities\n    validateFile,\n    getFileInfo,\n    formatFileSize,\n    getUploadSummary\n  };\n};\n\nexport default useDocumentUpload;"