import { useState, useCallback, useEffect, useMemo } from 'react';\nimport { calculateRidePrice } from '../utils/pricingCalculator';\n\n/**\n * usePricingCalculation Hook\n * Manages pricing calculations for different service types and booking configurations\n */\nconst usePricingCalculation = ({\n  selectedService,\n  formData,\n  serviceData,\n  externalEstimate = null\n} = {}) => {\n  // Pricing state\n  const [estimate, setEstimate] = useState(null);\n  const [isCalculating, setIsCalculating] = useState(false);\n  const [calculationError, setCalculationError] = useState(null);\n  const [priceBreakdown, setPriceBreakdown] = useState(null);\n  \n  // Calculate base price for the service\n  const calculateBasePrice = useCallback(async (pickup, dropoff, service, data) => {\n    if (!pickup || !dropoff) {\n      return null;\n    }\n    \n    try {\n      setIsCalculating(true);\n      setCalculationError(null);\n      \n      // Use external pricing calculator\n      const result = await calculateRidePrice({\n        serviceType: service,\n        pickupLocation: pickup,\n        dropoffLocation: dropoff,\n        passengers: formData?.passengers || 1,\n        isRoundTrip: formData?.isRoundTrip || false,\n        serviceSpecificData: data\n      });\n      \n      return result;\n    } catch (error) {\n      console.error('Pricing calculation error:', error);\n      setCalculationError(error.message || 'Failed to calculate price');\n      return null;\n    } finally {\n      setIsCalculating(false);\n    }\n  }, [formData]);\n  \n  // Calculate scheduling multiplier\n  const getSchedulingMultiplier = useCallback((scheduleType, selectedDates) => {\n    switch (scheduleType) {\n      case 'instant':\n        return 1.0;\n      case 'specific_time':\n        return 1.1; // 10% premium for scheduled rides\n      case 'specific_dates':\n        // Bulk discount for multiple dates\n        const dateCount = selectedDates?.length || 1;\n        if (dateCount >= 10) return 0.85; // 15% discount\n        if (dateCount >= 5) return 0.9;   // 10% discount\n        return 1.0;\n      case 'weekdays':\n      case 'weekends':\n        return 0.9; // 10% discount for recurring rides\n      default:\n        return 1.0;\n    }\n  }, []);\n  \n  // Calculate service-specific adjustments\n  const getServiceAdjustments = useCallback((service, data) => {\n    const adjustments = {\n      baseMultiplier: 1.0,\n      additionalFees: 0,\n      description: []\n    };\n    \n    switch (service) {\n      case 'taxi':\n        // No additional adjustments for basic taxi\n        break;\n        \n      case 'courier':\n        if (data.package?.weight > 10) {\n          adjustments.additionalFees += 5;\n          adjustments.description.push('Heavy package fee: $5');\n        }\n        if (data.package?.fragile) {\n          adjustments.baseMultiplier *= 1.2;\n          adjustments.description.push('Fragile handling: +20%');\n        }\n        break;\n        \n      case 'errands':\n        const taskCount = data.tasks?.length || 1;\n        if (taskCount > 3) {\n          adjustments.additionalFees += (taskCount - 3) * 3;\n          adjustments.description.push(`Multiple tasks fee: $${(taskCount - 3) * 3}`);\n        }\n        break;\n        \n      case 'school_run':\n        if (data.passengers?.length > 1) {\n          adjustments.baseMultiplier *= 1.1;\n          adjustments.description.push('Multiple passengers: +10%');\n        }\n        break;\n        \n      case 'bulk':\n        const passengerCount = data.totalPassengers || 1;\n        if (passengerCount > 4) {\n          adjustments.baseMultiplier *= 1.3;\n          adjustments.description.push('Large group: +30%');\n        }\n        break;\n    }\n    \n    return adjustments;\n  }, []);\n  \n  // Calculate final price with all adjustments\n  const calculateFinalPrice = useCallback((baseEstimate, scheduleType, selectedDates, service, data) => {\n    if (!baseEstimate) return null;\n    \n    const schedulingMultiplier = getSchedulingMultiplier(scheduleType, selectedDates);\n    const serviceAdjustments = getServiceAdjustments(service, data);\n    \n    const adjustedBasePrice = baseEstimate.cost * serviceAdjustments.baseMultiplier * schedulingMultiplier;\n    const finalPrice = adjustedBasePrice + serviceAdjustments.additionalFees;\n    \n    const breakdown = {\n      basePrice: baseEstimate.cost,\n      schedulingMultiplier,\n      serviceMultiplier: serviceAdjustments.baseMultiplier,\n      additionalFees: serviceAdjustments.additionalFees,\n      finalPrice,\n      adjustmentDescriptions: serviceAdjustments.description,\n      distance: baseEstimate.distance,\n      duration: baseEstimate.duration\n    };\n    \n    return {\n      ...baseEstimate,\n      cost: finalPrice,\n      breakdown\n    };\n  }, [getSchedulingMultiplier, getServiceAdjustments]);\n  \n  // Recalculate pricing when dependencies change\n  useEffect(() => {\n    const recalculatePrice = async () => {\n      if (!formData?.pickupLocation || !formData?.dropoffLocation) {\n        setEstimate(null);\n        setPriceBreakdown(null);\n        return;\n      }\n      \n      // Use external estimate if provided\n      if (externalEstimate) {\n        const finalEstimate = calculateFinalPrice(\n          externalEstimate,\n          formData.scheduleType,\n          formData.selectedDates,\n          selectedService,\n          serviceData\n        );\n        setEstimate(finalEstimate);\n        setPriceBreakdown(finalEstimate?.breakdown);\n        return;\n      }\n      \n      // Calculate from scratch\n      const baseEstimate = await calculateBasePrice(\n        formData.pickupLocation,\n        formData.dropoffLocation,\n        selectedService,\n        serviceData\n      );\n      \n      if (baseEstimate) {\n        const finalEstimate = calculateFinalPrice(\n          baseEstimate,\n          formData.scheduleType,\n          formData.selectedDates,\n          selectedService,\n          serviceData\n        );\n        setEstimate(finalEstimate);\n        setPriceBreakdown(finalEstimate?.breakdown);\n      }\n    };\n    \n    recalculatePrice();\n  }, [\n    formData?.pickupLocation,\n    formData?.dropoffLocation,\n    formData?.scheduleType,\n    formData?.selectedDates,\n    formData?.isRoundTrip,\n    formData?.passengers,\n    selectedService,\n    serviceData,\n    externalEstimate,\n    calculateBasePrice,\n    calculateFinalPrice\n  ]);\n  \n  // Calculate trip count for display\n  const tripCount = useMemo(() => {\n    if (!formData) return 1;\n    \n    switch (formData.scheduleType) {\n      case 'specific_dates':\n        return formData.selectedDates?.length || 1;\n      case 'weekdays':\n        // Approximate weekdays in a month\n        return 22;\n      case 'weekends':\n        // Approximate weekends in a month\n        return 8;\n      default:\n        return 1;\n    }\n  }, [formData]);\n  \n  // Format price for display\n  const formattedPrice = useMemo(() => {\n    if (!estimate) return null;\n    return `$${estimate.cost.toFixed(2)}`;\n  }, [estimate]);\n  \n  // Calculate total cost for multiple trips\n  const totalCost = useMemo(() => {\n    if (!estimate) return null;\n    return estimate.cost * tripCount;\n  }, [estimate, tripCount]);\n  \n  const formattedTotalCost = useMemo(() => {\n    if (!totalCost) return null;\n    return `$${totalCost.toFixed(2)}`;\n  }, [totalCost]);\n  \n  // Manual price recalculation\n  const recalculatePrice = useCallback(() => {\n    if (formData?.pickupLocation && formData?.dropoffLocation) {\n      // Trigger recalculation by updating a dependency\n      setCalculationError(null);\n    }\n  }, [formData]);\n  \n  return {\n    // Pricing data\n    estimate,\n    priceBreakdown,\n    formattedPrice,\n    totalCost,\n    formattedTotalCost,\n    tripCount,\n    \n    // State\n    isCalculating,\n    calculationError,\n    \n    // Actions\n    recalculatePrice,\n    \n    // Helpers\n    getSchedulingMultiplier,\n    getServiceAdjustments\n  };\n};\n\nexport default usePricingCalculation;\n