import { useState, useCallback, useMemo } from 'react';\n\n/**\n * useProfileForm Hook\n * \n * Provides common form logic for profile forms including:\n * - Form state management\n * - Validation utilities\n * - Field change handlers\n * - Error management\n * - Progress calculation\n */\nconst useProfileForm = ({\n  initialData = {},\n  validationRules = {},\n  totalSteps = 5\n}) => {\n  const [formData, setFormData] = useState(initialData);\n  const [errors, setErrors] = useState({});\n  const [touchedFields, setTouchedFields] = useState(new Set());\n  const [isDirty, setIsDirty] = useState(false);\n\n  // Handle input changes\n  const handleInputChange = useCallback((name, value) => {\n    setFormData(prev => ({ ...prev, [name]: value }));\n    setIsDirty(true);\n    \n    // Mark field as touched\n    setTouchedFields(prev => new Set([...prev, name]));\n    \n    // Clear error for this field\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  }, [errors]);\n\n  // Handle file changes\n  const handleFileChange = useCallback((fieldName, file) => {\n    setFormData(prev => ({ ...prev, [fieldName]: file }));\n    setIsDirty(true);\n    \n    // Mark field as touched\n    setTouchedFields(prev => new Set([...prev, fieldName]));\n    \n    // Clear error for this field\n    if (errors[fieldName]) {\n      setErrors(prev => ({ ...prev, [fieldName]: '' }));\n    }\n  }, [errors]);\n\n  // Set field error\n  const setFieldError = useCallback((fieldName, errorMessage) => {\n    setErrors(prev => ({ ...prev, [fieldName]: errorMessage }));\n  }, []);\n\n  // Clear all errors\n  const clearErrors = useCallback(() => {\n    setErrors({});\n  }, []);\n\n  // Clear specific field error\n  const clearFieldError = useCallback((fieldName) => {\n    setErrors(prev => {\n      const newErrors = { ...prev };\n      delete newErrors[fieldName];\n      return newErrors;\n    });\n  }, []);\n\n  // Validate a single field\n  const validateField = useCallback((fieldName, value = formData[fieldName]) => {\n    const rules = validationRules[fieldName];\n    if (!rules) return null;\n\n    for (const rule of rules) {\n      const { required, validator, message } = rule;\n      \n      if (required && (!value || (typeof value === 'string' && !value.trim()))) {\n        return message || `${fieldName} is required`;\n      }\n      \n      if (value && validator && !validator(value)) {\n        return message || `Invalid ${fieldName}`;\n      }\n    }\n    \n    return null;\n  }, [formData, validationRules]);\n\n  // Validate a step\n  const validateStep = useCallback((step, stepValidationRules = validationRules) => {\n    if (!stepValidationRules || !stepValidationRules[step]) {\n      return { isValid: true, errors: {} };\n    }\n\n    const newErrors = {};\n    const rules = stepValidationRules[step];\n\n    rules.forEach(rule => {\n      const { field, required, validator, message } = rule;\n      const value = formData[field];\n\n      if (required && (!value || (typeof value === 'string' && !value.trim()))) {\n        newErrors[field] = message || `${field} is required`;\n      } else if (value && validator && !validator(value)) {\n        newErrors[field] = message || `Invalid ${field}`;\n      }\n    });\n\n    setErrors(prev => ({ ...prev, ...newErrors }));\n    return {\n      isValid: Object.keys(newErrors).length === 0,\n      errors: newErrors\n    };\n  }, [formData, validationRules]);\n\n  // Validate all fields\n  const validateAll = useCallback(() => {\n    const allErrors = {};\n    \n    Object.keys(validationRules).forEach(stepOrField => {\n      if (Array.isArray(validationRules[stepOrField])) {\n        // It's a field validation rule\n        const error = validateField(stepOrField);\n        if (error) {\n          allErrors[stepOrField] = error;\n        }\n      } else {\n        // It's a step validation rule\n        const { errors: stepErrors } = validateStep(stepOrField);\n        Object.assign(allErrors, stepErrors);\n      }\n    });\n    \n    setErrors(allErrors);\n    return Object.keys(allErrors).length === 0;\n  }, [validateField, validateStep, validationRules]);\n\n  // Calculate completion percentage\n  const completionPercentage = useMemo(() => {\n    const requiredFields = [];\n    \n    // Extract required fields from validation rules\n    Object.values(validationRules).forEach(rules => {\n      if (Array.isArray(rules)) {\n        rules.forEach(rule => {\n          if (rule.required && rule.field) {\n            requiredFields.push(rule.field);\n          }\n        });\n      }\n    });\n    \n    if (requiredFields.length === 0) return 0;\n    \n    const completedFields = requiredFields.filter(field => {\n      const value = formData[field];\n      return value && (typeof value !== 'string' || value.trim());\n    });\n    \n    return Math.round((completedFields.length / requiredFields.length) * 100);\n  }, [formData, validationRules]);\n\n  // Calculate step completion\n  const getStepCompletion = useCallback((step) => {\n    const stepRules = validationRules[step];\n    if (!stepRules || !Array.isArray(stepRules)) return 100;\n    \n    const requiredFields = stepRules\n      .filter(rule => rule.required)\n      .map(rule => rule.field);\n    \n    if (requiredFields.length === 0) return 100;\n    \n    const completedFields = requiredFields.filter(field => {\n      const value = formData[field];\n      return value && (typeof value !== 'string' || value.trim());\n    });\n    \n    return Math.round((completedFields.length / requiredFields.length) * 100);\n  }, [formData, validationRules]);\n\n  // Check if step is valid\n  const isStepValid = useCallback((step) => {\n    const { isValid } = validateStep(step);\n    return isValid;\n  }, [validateStep]);\n\n  // Get field props for easy binding\n  const getFieldProps = useCallback((fieldName) => {\n    return {\n      name: fieldName,\n      value: formData[fieldName] || '',\n      onChange: (value) => handleInputChange(fieldName, value),\n      error: errors[fieldName],\n      touched: touchedFields.has(fieldName)\n    };\n  }, [formData, errors, touchedFields, handleInputChange]);\n\n  // Get file field props\n  const getFileFieldProps = useCallback((fieldName) => {\n    return {\n      name: fieldName,\n      file: formData[fieldName],\n      onChange: (file) => handleFileChange(fieldName, file),\n      error: errors[fieldName],\n      touched: touchedFields.has(fieldName)\n    };\n  }, [formData, errors, touchedFields, handleFileChange]);\n\n  // Reset form\n  const resetForm = useCallback((newData = {}) => {\n    setFormData({ ...initialData, ...newData });\n    setErrors({});\n    setTouchedFields(new Set());\n    setIsDirty(false);\n  }, [initialData]);\n\n  // Update form data\n  const updateFormData = useCallback((updates) => {\n    setFormData(prev => ({ ...prev, ...updates }));\n    setIsDirty(true);\n  }, []);\n\n  // Check if form has errors\n  const hasErrors = useMemo(() => {\n    return Object.keys(errors).length > 0;\n  }, [errors]);\n\n  // Check if form is complete\n  const isComplete = useMemo(() => {\n    return completionPercentage === 100;\n  }, [completionPercentage]);\n\n  return {\n    // State\n    formData,\n    errors,\n    touchedFields,\n    isDirty,\n    hasErrors,\n    isComplete,\n    completionPercentage,\n    \n    // Handlers\n    handleInputChange,\n    handleFileChange,\n    setFieldError,\n    clearErrors,\n    clearFieldError,\n    \n    // Validation\n    validateField,\n    validateStep,\n    validateAll,\n    isStepValid,\n    getStepCompletion,\n    \n    // Utilities\n    getFieldProps,\n    getFileFieldProps,\n    resetForm,\n    updateFormData\n  };\n};\n\nexport default useProfileForm;"