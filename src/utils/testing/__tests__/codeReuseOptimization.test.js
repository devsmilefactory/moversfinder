/**\n * Property Test: Code Reuse Optimization\n * **Feature: component-modularization, Property 5: Code reuse optimization**\n * **Validates: Requirements 2.2, 3.1**\n * \n * Tests that code reuse is optimized through shared components, hooks, and utilities.\n * This property-based test validates that duplicate code patterns are minimized.\n */\n\nimport { describe, test, expect } from 'vitest';\nimport fc from 'fast-check';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Code pattern detection utilities\nclass CodePatternAnalyzer {\n  constructor() {\n    this.patterns = new Map();\n    this.duplicateThreshold = 3; // Minimum occurrences to consider duplication\n    this.minPatternLength = 20; // Minimum characters for a pattern\n  }\n\n  // Extract meaningful code patterns (excluding comments and whitespace)\n  extractPatterns(content) {\n    const lines = content\n      .split('\\n')\n      .map(line => line.trim())\n      .filter(line => {\n        // Filter out comments, empty lines, and imports\n        return line && \n               !line.startsWith('//') && \n               !line.startsWith('/*') && \n               !line.startsWith('*') && \n               !line.startsWith('import') && \n               !line.startsWith('export') &&\n               line.length > 10;\n      });\n\n    const patterns = [];\n    \n    // Extract multi-line patterns\n    for (let i = 0; i < lines.length - 2; i++) {\n      for (let j = 3; j <= Math.min(8, lines.length - i); j++) {\n        const pattern = lines.slice(i, i + j).join('\\n');\n        if (pattern.length >= this.minPatternLength) {\n          patterns.push(this.normalizePattern(pattern));\n        }\n      }\n    }\n    \n    return patterns;\n  }\n\n  // Normalize patterns to detect semantic similarity\n  normalizePattern(pattern) {\n    return pattern\n      // Remove variable names and string literals\n      .replace(/\\b[a-zA-Z_$][a-zA-Z0-9_$]*\\b/g, 'VAR')\n      .replace(/['\"`][^'\"\\`]*['\"`]/g, 'STRING')\n      .replace(/\\d+/g, 'NUM')\n      // Normalize whitespace\n      .replace(/\\s+/g, ' ')\n      .trim();\n  }\n\n  // Analyze files for duplicate patterns\n  analyzeFiles(filePaths) {\n    const patternOccurrences = new Map();\n    const filePatterns = new Map();\n\n    filePaths.forEach(filePath => {\n      try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const patterns = this.extractPatterns(content);\n        \n        filePatterns.set(filePath, patterns);\n        \n        patterns.forEach(pattern => {\n          if (!patternOccurrences.has(pattern)) {\n            patternOccurrences.set(pattern, []);\n          }\n          patternOccurrences.get(pattern).push(filePath);\n        });\n      } catch (error) {\n        console.warn(`Could not analyze ${filePath}:`, error.message);\n      }\n    });\n\n    // Find duplicated patterns\n    const duplicates = new Map();\n    patternOccurrences.forEach((files, pattern) => {\n      if (files.length >= this.duplicateThreshold) {\n        duplicates.set(pattern, files);\n      }\n    });\n\n    return {\n      patternOccurrences,\n      filePatterns,\n      duplicates,\n      totalPatterns: patternOccurrences.size,\n      duplicatePatterns: duplicates.size\n    };\n  }\n}\n\n// Get all source files\nfunction getAllSourceFiles(dir, files = []) {\n  const entries = fs.readdirSync(dir, { withFileTypes: true });\n  \n  for (const entry of entries) {\n    const fullPath = path.join(dir, entry.name);\n    \n    if (entry.isDirectory()) {\n      if (!['node_modules', '.git', 'build', 'dist', '.next', '__tests__'].includes(entry.name)) {\n        getAllSourceFiles(fullPath, files);\n      }\n    } else if (entry.isFile()) {\n      if (/\\.(jsx?|tsx?)$/.test(entry.name) && \n          !entry.name.includes('.test.') && \n          !entry.name.includes('.spec.')) {\n        files.push(fullPath);\n      }\n    }\n  }\n  \n  return files;\n}\n\n// Analyze shared component usage\nfunction analyzeSharedComponentUsage(filePaths) {\n  const sharedImports = new Map();\n  const componentUsage = new Map();\n  \n  filePaths.forEach(filePath => {\n    try {\n      const content = fs.readFileSync(filePath, 'utf8');\n      const lines = content.split('\\n');\n      \n      lines.forEach(line => {\n        // Find imports from shared directories\n        const sharedImportMatch = line.match(/import.*from\\s+['\"]([^'\"]*(?:shared|common|ui|forms)[^'\"]*)['\"]/);\n        if (sharedImportMatch) {\n          const importPath = sharedImportMatch[1];\n          if (!sharedImports.has(importPath)) {\n            sharedImports.set(importPath, []);\n          }\n          sharedImports.get(importPath).push(filePath);\n        }\n        \n        // Find component usage patterns\n        const componentMatch = line.match(/<([A-Z][a-zA-Z0-9]*)/g);\n        if (componentMatch) {\n          componentMatch.forEach(match => {\n            const componentName = match.substring(1);\n            if (!componentUsage.has(componentName)) {\n              componentUsage.set(componentName, []);\n            }\n            componentUsage.get(componentName).push(filePath);\n          });\n        }\n      });\n    } catch (error) {\n      console.warn(`Could not analyze ${filePath}:`, error.message);\n    }\n  });\n  \n  return { sharedImports, componentUsage };\n}\n\n// Analyze hook usage patterns\nfunction analyzeHookUsage(filePaths) {\n  const hookUsage = new Map();\n  const customHooks = new Set();\n  \n  filePaths.forEach(filePath => {\n    try {\n      const content = fs.readFileSync(filePath, 'utf8');\n      const fileName = path.basename(filePath, path.extname(filePath));\n      \n      // Identify custom hooks\n      if (fileName.startsWith('use') && filePath.includes('/hooks/')) {\n        customHooks.add(fileName);\n      }\n      \n      // Find hook usage\n      const hookMatches = content.match(/\\buse[A-Z][a-zA-Z0-9]*\\b/g);\n      if (hookMatches) {\n        hookMatches.forEach(hookName => {\n          if (!hookUsage.has(hookName)) {\n            hookUsage.set(hookName, []);\n          }\n          hookUsage.get(hookName).push(filePath);\n        });\n      }\n    } catch (error) {\n      console.warn(`Could not analyze ${filePath}:`, error.message);\n    }\n  });\n  \n  return { hookUsage, customHooks };\n}\n\ndescribe('Property Test: Code Reuse Optimization', () => {\n  const srcDir = path.resolve(__dirname, '../../../');\n  const sourceFiles = getAllSourceFiles(srcDir);\n  const analyzer = new CodePatternAnalyzer();\n  \n  test('duplicate code patterns should be minimized', () => {\n    const analysis = analyzer.analyzeFiles(sourceFiles);\n    \n    console.log(`Total patterns found: ${analysis.totalPatterns}`);\n    console.log(`Duplicate patterns: ${analysis.duplicatePatterns}`);\n    \n    // Property: Duplicate pattern ratio should be low\n    const duplicateRatio = analysis.duplicatePatterns / analysis.totalPatterns;\n    expect(duplicateRatio).toBeLessThan(0.15); // Less than 15% duplication\n    \n    // Log the most duplicated patterns for review\n    const sortedDuplicates = Array.from(analysis.duplicates.entries())\n      .sort((a, b) => b[1].length - a[1].length)\n      .slice(0, 5);\n    \n    console.log('Top duplicate patterns:');\n    sortedDuplicates.forEach(([pattern, files], index) => {\n      console.log(`${index + 1}. Found in ${files.length} files:`);\n      console.log(`   Pattern: ${pattern.substring(0, 100)}...`);\n    });\n  });\n  \n  test('shared components should be widely reused', () => {\n    const { sharedImports, componentUsage } = analyzeSharedComponentUsage(sourceFiles);\n    \n    // Property: Shared components should have multiple consumers\n    const wellUsedSharedComponents = Array.from(sharedImports.entries())\n      .filter(([_, files]) => files.length >= 3);\n    \n    const totalSharedComponents = sharedImports.size;\n    const reusedRatio = wellUsedSharedComponents.length / Math.max(totalSharedComponents, 1);\n    \n    console.log(`Shared components: ${totalSharedComponents}`);\n    console.log(`Well-used shared components: ${wellUsedSharedComponents.length}`);\n    console.log(`Reuse ratio: ${(reusedRatio * 100).toFixed(1)}%`);\n    \n    // Property: At least 60% of shared components should be reused\n    if (totalSharedComponents > 0) {\n      expect(reusedRatio).toBeGreaterThan(0.6);\n    }\n    \n    // Property: Popular UI components should be highly reused\n    const uiComponents = ['Button', 'Input', 'Modal', 'Card', 'FormInput', 'FormSelect'];\n    uiComponents.forEach(componentName => {\n      const usage = componentUsage.get(componentName);\n      if (usage && usage.length > 0) {\n        expect(usage.length).toBeGreaterThan(2); // Should be used in multiple places\n      }\n    });\n  });\n  \n  test('custom hooks should promote code reuse', () => {\n    const { hookUsage, customHooks } = analyzeHookUsage(sourceFiles);\n    \n    console.log(`Custom hooks found: ${customHooks.size}`);\n    \n    // Property: Custom hooks should be reused across components\n    const reusedHooks = Array.from(hookUsage.entries())\n      .filter(([hookName, files]) => {\n        return customHooks.has(hookName) && files.length >= 2;\n      });\n    \n    const customHookArray = Array.from(customHooks);\n    const reuseRatio = reusedHooks.length / Math.max(customHookArray.length, 1);\n    \n    console.log(`Reused custom hooks: ${reusedHooks.length}`);\n    console.log(`Hook reuse ratio: ${(reuseRatio * 100).toFixed(1)}%`);\n    \n    // Property: At least 50% of custom hooks should be reused\n    if (customHookArray.length > 0) {\n      expect(reuseRatio).toBeGreaterThan(0.5);\n    }\n    \n    // Property: Form-related hooks should be widely used\n    const formHooks = ['useFormValidation', 'useFormSubmission', 'useStepNavigation'];\n    formHooks.forEach(hookName => {\n      const usage = hookUsage.get(hookName);\n      if (usage) {\n        expect(usage.length).toBeGreaterThan(1); // Should be used in multiple components\n      }\n    });\n  });\n  \n  test('utility functions should reduce code duplication', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          functionType: fc.constantFrom('validation', 'formatting', 'calculation', 'api'),\n          complexity: fc.constantFrom('simple', 'moderate', 'complex'),\n          usageCount: fc.integer({ min: 1, max: 20 })\n        }),\n        (utilSpec) => {\n          // Property: Utility functions should justify their existence through reuse\n          if (utilSpec.complexity === 'complex') {\n            // Complex utilities should be used at least 3 times\n            return utilSpec.usageCount >= 3;\n          } else if (utilSpec.complexity === 'moderate') {\n            // Moderate utilities should be used at least 2 times\n            return utilSpec.usageCount >= 2;\n          } else {\n            // Simple utilities can be used just once if they improve readability\n            return utilSpec.usageCount >= 1;\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n  \n  test('component composition should reduce duplication', () => {\n    // Test that components are properly composed rather than duplicated\n    const bookingComponents = sourceFiles.filter(filePath => \n      filePath.includes('/booking/') && !filePath.includes('test')\n    );\n    \n    if (bookingComponents.length > 0) {\n      const compositionAnalysis = analyzer.analyzeFiles(bookingComponents);\n      \n      // Property: Booking components should have low duplication due to composition\n      const duplicateRatio = compositionAnalysis.duplicatePatterns / compositionAnalysis.totalPatterns;\n      expect(duplicateRatio).toBeLessThan(0.1); // Less than 10% duplication in modular components\n      \n      console.log(`Booking component duplication: ${(duplicateRatio * 100).toFixed(1)}%`);\n    }\n  });\n  \n  test('shared patterns should be extracted into reusable components', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          patternType: fc.constantFrom('form', 'list', 'card', 'modal', 'button'),\n          occurrences: fc.integer({ min: 1, max: 15 }),\n          complexity: fc.constantFrom('low', 'medium', 'high')\n        }),\n        (pattern) => {\n          // Property: Patterns that occur frequently should be extracted\n          if (pattern.occurrences >= 5 && pattern.complexity !== 'low') {\n            // High-occurrence, non-trivial patterns should be componentized\n            return true; // Assume they should be extracted\n          }\n          \n          if (pattern.occurrences >= 8) {\n            // Very high occurrence patterns should always be extracted\n            return true;\n          }\n          \n          // Low occurrence or simple patterns can remain inline\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n  \n  test('import patterns should indicate good code organization', () => {\n    const importAnalysis = new Map();\n    \n    sourceFiles.forEach(filePath => {\n      try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const imports = content.match(/^import.*from\\s+['\"][^'\"]+['\"]/gm) || [];\n        \n        imports.forEach(importLine => {\n          const match = importLine.match(/from\\s+['\"]([^'\"]+)['\"]/);;\n          if (match) {\n            const importPath = match[1];\n            if (!importAnalysis.has(importPath)) {\n              importAnalysis.set(importPath, 0);\n            }\n            importAnalysis.set(importPath, importAnalysis.get(importPath) + 1);\n          }\n        });\n      } catch (error) {\n        // Skip files that can't be read\n      }\n    });\n    \n    // Property: Shared modules should have high import counts\n    const sharedModules = Array.from(importAnalysis.entries())\n      .filter(([path, _]) => path.includes('shared') || path.includes('common') || path.includes('ui'))\n      .sort((a, b) => b[1] - a[1]);\n    \n    if (sharedModules.length > 0) {\n      const topSharedModule = sharedModules[0];\n      expect(topSharedModule[1]).toBeGreaterThan(3); // Should be imported by multiple files\n    }\n  });\n});\n