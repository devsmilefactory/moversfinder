import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { renderHook, act } from '@testing-library/react';\nimport React, { memo, useState, useCallback, useMemo } from 'react';\nimport { fc } from '@fast-check/vitest';\nimport { generateComponentProps, generateFormData } from '../mockData';\n\n/**\n * **Feature: component-modularization, Property 8: Render optimization**\n * **Validates: Requirements 4.3, 4.4**\n * \n * Property-based tests for render optimization compliance.\n * Ensures components follow React performance best practices.\n */\n\n// Mock components for testing\nconst TestComponent = memo(({ data, onUpdate, children }) => {\n  const [localState, setLocalState] = useState(0);\n  \n  const memoizedValue = useMemo(() => {\n    return data?.items?.length || 0;\n  }, [data?.items?.length]);\n  \n  const handleClick = useCallback(() => {\n    onUpdate?.(localState + 1);\n    setLocalState(prev => prev + 1);\n  }, [onUpdate, localState]);\n  \n  return (\n    <div data-testid=\"test-component\">\n      <span data-testid=\"memoized-value\">{memoizedValue}</span>\n      <button data-testid=\"update-button\" onClick={handleClick}>\n        Update ({localState})\n      </button>\n      {children}\n    </div>\n  );\n});\n\nconst UnoptimizedComponent = ({ data, onUpdate, children }) => {\n  const [localState, setLocalState] = useState(0);\n  \n  // Intentionally unoptimized - recalculates on every render\n  const expensiveValue = data?.items?.reduce((sum, item) => sum + (item?.value || 0), 0) || 0;\n  \n  const handleClick = () => {\n    onUpdate?.(localState + 1);\n    setLocalState(prev => prev + 1);\n  };\n  \n  return (\n    <div data-testid=\"unoptimized-component\">\n      <span data-testid=\"expensive-value\">{expensiveValue}</span>\n      <button data-testid=\"update-button\" onClick={handleClick}>\n        Update ({localState})\n      </button>\n      {children}\n    </div>\n  );\n};\n\n// Profile form step components for testing\nconst ProfileStepComponent = memo(({ formData, errors, onChange, step }) => {\n  const memoizedFields = useMemo(() => {\n    return Object.keys(formData || {}).filter(key => key.startsWith(step));\n  }, [formData, step]);\n  \n  const handleFieldChange = useCallback((field, value) => {\n    onChange?.(field, value);\n  }, [onChange]);\n  \n  return (\n    <div data-testid={`profile-step-${step}`}>\n      {memoizedFields.map(field => (\n        <input\n          key={field}\n          data-testid={`field-${field}`}\n          value={formData?.[field] || ''}\n          onChange={(e) => handleFieldChange(field, e.target.value)}\n        />\n      ))}\n      {errors?.[step] && (\n        <span data-testid=\"error-message\">{errors[step]}</span>\n      )}\n    </div>\n  );\n});\n\ndescribe('Property 8: Render Optimization', () => {\n  let renderCount = 0;\n  let mockOnUpdate;\n  \n  beforeEach(() => {\n    renderCount = 0;\n    mockOnUpdate = vi.fn();\n  });\n  \n  describe('React.memo optimization', () => {\n    it.prop([fc.record({\n      data: fc.record({\n        items: fc.array(fc.record({ value: fc.integer() }), { maxLength: 10 })\n      }),\n      initialProps: generateComponentProps()\n    })])('should prevent unnecessary re-renders when props haven\\'t changed', ({ data, initialProps }) => {\n      const TestWrapper = ({ data, ...props }) => {\n        const [count, setCount] = useState(0);\n        \n        // Track renders\n        const MemoizedComponent = memo(() => {\n          renderCount++;\n          return <TestComponent data={data} {...props} />;\n        });\n        \n        return (\n          <div>\n            <button data-testid=\"parent-update\" onClick={() => setCount(c => c + 1)}>\n              Parent Update ({count})\n            </button>\n            <MemoizedComponent />\n          </div>\n        );\n      };\n      \n      render(<TestWrapper data={data} {...initialProps} />);\n      \n      const initialRenderCount = renderCount;\n      \n      // Update parent state without changing props\n      fireEvent.click(screen.getByTestId('parent-update'));\n      \n      // Component should not re-render if props haven't changed\n      expect(renderCount).toBe(initialRenderCount);\n    });\n    \n    it.prop([fc.array(generateComponentProps(), { minLength: 2, maxLength: 5 })])(\n      'should re-render only when props actually change',\n      (propsList) => {\n        const TestWrapper = ({ currentProps }) => {\n          const MemoizedComponent = memo(({ data }) => {\n            renderCount++;\n            return <div data-testid=\"memo-component\">{JSON.stringify(data)}</div>;\n          });\n          \n          return <MemoizedComponent data={currentProps} />;\n        };\n        \n        const { rerender } = render(<TestWrapper currentProps={propsList[0]} />);\n        const initialRenderCount = renderCount;\n        \n        // Re-render with same props\n        rerender(<TestWrapper currentProps={propsList[0]} />);\n        expect(renderCount).toBe(initialRenderCount);\n        \n        // Re-render with different props\n        rerender(<TestWrapper currentProps={propsList[1]} />);\n        expect(renderCount).toBe(initialRenderCount + 1);\n      }\n    );\n  });\n  \n  describe('useMemo optimization', () => {\n    it.prop([fc.record({\n      items: fc.array(fc.record({ value: fc.integer() }), { maxLength: 20 })\n    })])('should memoize expensive calculations', ({ items }) => {\n      let calculationCount = 0;\n      \n      const TestComponent = ({ data }) => {\n        const [localState, setLocalState] = useState(0);\n        \n        const expensiveValue = useMemo(() => {\n          calculationCount++;\n          return data?.items?.reduce((sum, item) => sum + item.value, 0) || 0;\n        }, [data?.items]);\n        \n        return (\n          <div>\n            <span data-testid=\"expensive-value\">{expensiveValue}</span>\n            <button \n              data-testid=\"local-update\" \n              onClick={() => setLocalState(s => s + 1)}\n            >\n              Local Update ({localState})\n            </button>\n          </div>\n        );\n      };\n      \n      render(<TestComponent data={{ items }} />);\n      \n      const initialCalculationCount = calculationCount;\n      \n      // Update local state - should not recalculate expensive value\n      fireEvent.click(screen.getByTestId('local-update'));\n      \n      expect(calculationCount).toBe(initialCalculationCount);\n    });\n    \n    it.prop([fc.array(generateFormData(), { minLength: 2, maxLength: 5 })])(\n      'should recalculate memoized values when dependencies change',\n      (formDataList) => {\n        let calculationCount = 0;\n        \n        const TestComponent = ({ formData }) => {\n          const fieldCount = useMemo(() => {\n            calculationCount++;\n            return Object.keys(formData || {}).length;\n          }, [formData]);\n          \n          return <div data-testid=\"field-count\">{fieldCount}</div>;\n        };\n        \n        const { rerender } = render(<TestComponent formData={formDataList[0]} />);\n        const initialCalculationCount = calculationCount;\n        \n        // Re-render with same data - should not recalculate\n        rerender(<TestComponent formData={formDataList[0]} />);\n        expect(calculationCount).toBe(initialCalculationCount);\n        \n        // Re-render with different data - should recalculate\n        rerender(<TestComponent formData={formDataList[1]} />);\n        expect(calculationCount).toBe(initialCalculationCount + 1);\n      }\n    );\n  });\n  \n  describe('useCallback optimization', () => {\n    it.prop([fc.array(fc.string(), { maxLength: 10 })])(\n      'should memoize callback functions to prevent child re-renders',\n      (testData) => {\n        let childRenderCount = 0;\n        \n        const ChildComponent = memo(({ onUpdate }) => {\n          childRenderCount++;\n          return (\n            <button data-testid=\"child-button\" onClick={() => onUpdate('test')}>\n              Child Component\n            </button>\n          );\n        });\n        \n        const ParentComponent = ({ data }) => {\n          const [state, setState] = useState(0);\n          \n          const handleUpdate = useCallback((value) => {\n            setState(prev => prev + 1);\n          }, []); // No dependencies - callback should be stable\n          \n          return (\n            <div>\n              <span data-testid=\"parent-state\">{state}</span>\n              <button \n                data-testid=\"parent-button\" \n                onClick={() => setState(s => s + 1)}\n              >\n                Parent Update\n              </button>\n              <ChildComponent onUpdate={handleUpdate} />\n            </div>\n          );\n        };\n        \n        render(<ParentComponent data={testData} />);\n        \n        const initialChildRenderCount = childRenderCount;\n        \n        // Update parent state - child should not re-render due to memoized callback\n        fireEvent.click(screen.getByTestId('parent-button'));\n        \n        expect(childRenderCount).toBe(initialChildRenderCount);\n      }\n    );\n    \n    it.prop([fc.array(fc.string(), { minLength: 2, maxLength: 5 })])(\n      'should update callback when dependencies change',\n      (dependencies) => {\n        const callbackResults = [];\n        \n        const TestComponent = ({ dependency }) => {\n          const memoizedCallback = useCallback(() => {\n            return `result-${dependency}`;\n          }, [dependency]);\n          \n          // Capture callback result\n          callbackResults.push(memoizedCallback());\n          \n          return <div data-testid=\"test-component\">{memoizedCallback()}</div>;\n        };\n        \n        const { rerender } = render(<TestComponent dependency={dependencies[0]} />);\n        \n        // Re-render with same dependency\n        rerender(<TestComponent dependency={dependencies[0]} />);\n        \n        // Re-render with different dependency\n        rerender(<TestComponent dependency={dependencies[1]} />);\n        \n        // Should have different results for different dependencies\n        const uniqueResults = [...new Set(callbackResults)];\n        expect(uniqueResults.length).toBeGreaterThan(1);\n      }\n    );\n  });\n  \n  describe('Profile form step optimization', () => {\n    it.prop([fc.record({\n      formData: generateFormData(),\n      step: fc.constantFrom('personal', 'license', 'vehicle', 'documents', 'banking')\n    })])('should optimize profile step components', ({ formData, step }) => {\n      let stepRenderCount = 0;\n      \n      const OptimizedProfileStep = memo(({ formData, step, onChange }) => {\n        stepRenderCount++;\n        return <ProfileStepComponent formData={formData} step={step} onChange={onChange} />;\n      });\n      \n      const ParentForm = ({ formData, step }) => {\n        const [parentState, setParentState] = useState(0);\n        \n        const handleFieldChange = useCallback((field, value) => {\n          // Simulate field change\n        }, []);\n        \n        return (\n          <div>\n            <button \n              data-testid=\"parent-update\" \n              onClick={() => setParentState(s => s + 1)}\n            >\n              Parent Update ({parentState})\n            </button>\n            <OptimizedProfileStep \n              formData={formData} \n              step={step} \n              onChange={handleFieldChange} \n            />\n          </div>\n        );\n      };\n      \n      render(<ParentForm formData={formData} step={step} />);\n      \n      const initialRenderCount = stepRenderCount;\n      \n      // Update parent state - step should not re-render\n      fireEvent.click(screen.getByTestId('parent-update'));\n      \n      expect(stepRenderCount).toBe(initialRenderCount);\n    });\n  });\n  \n  describe('Performance comparison', () => {\n    it.prop([fc.record({\n      items: fc.array(fc.record({ value: fc.integer() }), { minLength: 10, maxLength: 50 })\n    })])('should demonstrate performance difference between optimized and unoptimized components', ({ items }) => {\n      const data = { items };\n      \n      // Measure optimized component\n      const optimizedStart = performance.now();\n      const { unmount: unmountOptimized } = render(\n        <TestComponent data={data} onUpdate={mockOnUpdate} />\n      );\n      const optimizedEnd = performance.now();\n      unmountOptimized();\n      \n      // Measure unoptimized component\n      const unoptimizedStart = performance.now();\n      const { unmount: unmountUnoptimized } = render(\n        <UnoptimizedComponent data={data} onUpdate={mockOnUpdate} />\n      );\n      const unoptimizedEnd = performance.now();\n      unmountUnoptimized();\n      \n      const optimizedTime = optimizedEnd - optimizedStart;\n      const unoptimizedTime = unoptimizedEnd - unoptimizedStart;\n      \n      // Both should render successfully (performance difference may vary)\n      expect(optimizedTime).toBeGreaterThan(0);\n      expect(unoptimizedTime).toBeGreaterThan(0);\n    });\n  });\n  \n  describe('Render optimization compliance', () => {\n    it.prop([fc.record({\n      componentProps: generateComponentProps(),\n      updates: fc.array(fc.record({\n        type: fc.constantFrom('props', 'state', 'context'),\n        value: fc.anything()\n      }), { maxLength: 5 })\n    })])('should follow React optimization best practices', ({ componentProps, updates }) => {\n      const renderCounts = { optimized: 0, unoptimized: 0 };\n      \n      const OptimizedComponent = memo(() => {\n        renderCounts.optimized++;\n        return <div data-testid=\"optimized\">Optimized</div>;\n      });\n      \n      const UnoptimizedComponent = () => {\n        renderCounts.unoptimized++;\n        return <div data-testid=\"unoptimized\">Unoptimized</div>;\n      };\n      \n      const TestWrapper = ({ trigger }) => {\n        const [state, setState] = useState(0);\n        \n        return (\n          <div>\n            <button \n              data-testid=\"trigger-update\" \n              onClick={() => setState(s => s + 1)}\n            >\n              Update ({state})\n            </button>\n            <OptimizedComponent />\n            <UnoptimizedComponent />\n          </div>\n        );\n      };\n      \n      render(<TestWrapper />);\n      \n      const initialOptimizedCount = renderCounts.optimized;\n      const initialUnoptimizedCount = renderCounts.unoptimized;\n      \n      // Trigger updates\n      updates.forEach(() => {\n        fireEvent.click(screen.getByTestId('trigger-update'));\n      });\n      \n      // Optimized component should render less frequently\n      expect(renderCounts.optimized).toBe(initialOptimizedCount);\n      expect(renderCounts.unoptimized).toBeGreaterThan(initialUnoptimizedCount);\n    });\n  });\n});\n\n// Integration test for profile form optimization\ndescribe('Profile Form Render Optimization Integration', () => {\n  it.prop([fc.record({\n    profileData: generateFormData(),\n    steps: fc.array(fc.constantFrom('personal', 'license', 'vehicle'), { minLength: 2, maxLength: 3 })\n  })])('should optimize multi-step profile forms', ({ profileData, steps }) => {\n    const stepRenderCounts = {};\n    \n    const OptimizedProfileForm = ({ data, currentStep }) => {\n      const [formState, setFormState] = useState(data);\n      \n      const handleFieldChange = useCallback((field, value) => {\n        setFormState(prev => ({ ...prev, [field]: value }));\n      }, []);\n      \n      const memoizedSteps = useMemo(() => {\n        return steps.map(step => {\n          const StepComponent = memo(({ step, data, onChange }) => {\n            stepRenderCounts[step] = (stepRenderCounts[step] || 0) + 1;\n            return <ProfileStepComponent step={step} formData={data} onChange={onChange} />;\n          });\n          \n          return (\n            <StepComponent \n              key={step}\n              step={step} \n              data={formState} \n              onChange={handleFieldChange} \n            />\n          );\n        });\n      }, [formState, handleFieldChange]);\n      \n      return (\n        <div data-testid=\"profile-form\">\n          {memoizedSteps}\n        </div>\n      );\n    };\n    \n    render(<OptimizedProfileForm data={profileData} currentStep={steps[0]} />);\n    \n    // All steps should render initially\n    steps.forEach(step => {\n      expect(stepRenderCounts[step]).toBe(1);\n    });\n  });\n});"